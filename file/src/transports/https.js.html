<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/transports/https.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/event.js~Event.html">Event</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-config">config</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">contexts</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/contexts/http.js~HTTP.html">HTTP</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">events</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/events/http_server_request.js~HTTPServerRequest.html">HTTPServerRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/events/http_server_response.js~HTTPServerResponse.html">HTTPServerResponse</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">middlewares</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-expressMiddleware">expressMiddleware</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-format">format</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-transform">transform</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-metadata_delimiter">metadata_delimiter</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/transports/https.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

import https from &apos;https&apos;
import { Writable } from &apos;stream&apos;

const HOSTNAME = &apos;logs.timber.io&apos;
const PATH = &apos;/frames&apos;
const CONTENT_TYPE = &apos;application/json&apos;
const USER_AGENT = `Timber Node HTTPS Stream/${require(&apos;../../package.json&apos;).version}`
const PORT = 443

// For debugging purposes, writes to /timber.log
// import fs from &apos;fs&apos;;
// import path from &apos;path&apos;;
// var logger = fs.createWriteStream(&apos;timber.log&apos;, { flags: &apos;a&apos; });

/**
 * A highly efficient stream for sending logs to Timber via HTTPS. It uses batches,
 * keep-alive connections (and in the future maybe msgpack) to deliver logs with high-throughput
 * and little overhead. It also implements the Stream.Writable interface so that it can be treated
 * like a stream. This is beneficial when using something like Morgan, where you can pass a custom stream.
*/

class HTTPSStream extends Writable {
  /**
    * @constructor
    * @param {string} apiKey - Timber API Key
    * @param {Object} [options] - Various options to adjust the stream behavior.
    * @param {string} [options.flushInterval=1000] - How often, in milliseconds, the messages written to the stream should be delivered to Timber.
    * @param {string} [options.httpsAgent] - Your own custom https.Agent. We use agents to maintain connection pools and keep the connections alive. This avoids the initial connection overhead every time we want to communicate with Timber. See https.Agent for options.
  */
  constructor(apiKey, {
    flushInterval = 1000,
    highWaterMark = 5000,
    httpsAgent,
    httpsClient,
    hostName = HOSTNAME,
    path = PATH,
    port = PORT
  } = {}) {
    // Ensure we use object mode and set a default highWaterMark
    super({ objectMode: true, highWaterMark })

    this.apiKey = apiKey
    this.hostName = hostName
    this.path = path
    this.port = port
    this.flushInterval = flushInterval
    this.httpsAgent = httpsAgent || new https.Agent({
      keepAlive: true,
      maxSockets: 3,
      // Keep the connection open for 1 minute, avoiding reconnects
      keepAliveMsecs: (1000 * 60)
    })
    this.httpsClient = httpsClient || https

    // Cork the stream so we can utilize the internal Buffer. We do *not* want to
    // send a request for every message. The _flusher will take care of flushing the stream
    // on an interval.
    this.cork()

    // In the event the _flusher is not fast enough, we need to monitor the buffer size.
    // If it fills before the next flush event, we should immediately flush.

    if (flushInterval !== undefined &amp;&amp; flushInterval &gt; 0) {
      this._startFlusher()
    }
  }

  /**
   * _writev is a Stream.Writeable methods that, if present, will write multiple chunks of
   * data off of the buffer. Defining it means we do not need to define _write.
   */
  _writev(chunks, next) {
    const messages = chunks.map(chunk =&gt; chunk.chunk)
    const body = JSON.stringify(messages)
    const options = {
      headers: {
        &apos;Content-Type&apos;: CONTENT_TYPE,
        &apos;Content-Length&apos;: Buffer.byteLength(body),
        &apos;User-Agent&apos;: USER_AGENT
      },
      agent: this.httpsAgent,
      auth: this.apiKey,
      hostname: this.hostName,
      port: this.port,
      path: this.path,
      method: &apos;POST&apos;
    }

    const req = this.httpsClient.request(options, resp =&gt; {})

    req.on(&apos;error&apos;, e =&gt; {})
    req.write(body)
    req.end()
    next()
  }

  _write(chunk, encoding, next) {
    this._writev([{ chunk, encoding }], next)
  }

  /**
   * Expressive function to flush the buffer contents. uncork flushes the buffer and write
   * the contents. Cork allows us to continue buffering the messages until the next flush.
   */
  _flush() {
    // nextTick is recommended here to allow batching of write calls I think
    process.nextTick(() =&gt; {
      this.uncork()
      this.cork()
    })
  }

  /**
   * Interval to call _flush continuously. This ensures log lines get sent on this.flushInterval
   * intervals.
   */
  _startFlusher() {
    setInterval(() =&gt; this._flush(), this.flushInterval)
  }
}

module.exports = HTTPSStream
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
